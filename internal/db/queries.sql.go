// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const countCompletedLessons = `-- name: CountCompletedLessons :one
SELECT COUNT(*) FROM lesson_progress
WHERE user_id = ? AND language = ? AND status = 'completed'
`

type CountCompletedLessonsParams struct {
	UserID   int64
	Language string
}

func (q *Queries) CountCompletedLessons(ctx context.Context, arg CountCompletedLessonsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCompletedLessons, arg.UserID, arg.Language)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createQuizAttempt = `-- name: CreateQuizAttempt :one
INSERT INTO quiz_attempts (user_id, language, lesson_id, score, total_questions, correct_answers)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, user_id, language, lesson_id, score, total_questions, correct_answers, attempted_at
`

type CreateQuizAttemptParams struct {
	UserID         int64
	Language       string
	LessonID       string
	Score          int64
	TotalQuestions int64
	CorrectAnswers int64
}

func (q *Queries) CreateQuizAttempt(ctx context.Context, arg CreateQuizAttemptParams) (QuizAttempt, error) {
	row := q.db.QueryRowContext(ctx, createQuizAttempt,
		arg.UserID,
		arg.Language,
		arg.LessonID,
		arg.Score,
		arg.TotalQuestions,
		arg.CorrectAnswers,
	)
	var i QuizAttempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Language,
		&i.LessonID,
		&i.Score,
		&i.TotalQuestions,
		&i.CorrectAnswers,
		&i.AttemptedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, email, password_hash, display_name)
VALUES (?, ?, ?, ?)
RETURNING id, username, email, password_hash, display_name, created_at
`

type CreateUserParams struct {
	Username     string
	Email        string
	PasswordHash string
	DisplayName  string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.DisplayName,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.CreatedAt,
	)
	return i, err
}

const getLessonProgress = `-- name: GetLessonProgress :one
SELECT id, user_id, language, lesson_id, status, best_score, attempts, last_accessed, completed_at FROM lesson_progress
WHERE user_id = ? AND language = ? AND lesson_id = ?
`

type GetLessonProgressParams struct {
	UserID   int64
	Language string
	LessonID string
}

func (q *Queries) GetLessonProgress(ctx context.Context, arg GetLessonProgressParams) (LessonProgress, error) {
	row := q.db.QueryRowContext(ctx, getLessonProgress, arg.UserID, arg.Language, arg.LessonID)
	var i LessonProgress
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Language,
		&i.LessonID,
		&i.Status,
		&i.BestScore,
		&i.Attempts,
		&i.LastAccessed,
		&i.CompletedAt,
	)
	return i, err
}

const getTotalScore = `-- name: GetTotalScore :one
SELECT COALESCE(SUM(best_score), 0) FROM lesson_progress
WHERE user_id = ? AND language = ?
`

type GetTotalScoreParams struct {
	UserID   int64
	Language string
}

func (q *Queries) GetTotalScore(ctx context.Context, arg GetTotalScoreParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getTotalScore, arg.UserID, arg.Language)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password_hash, display_name, created_at FROM users WHERE email = ?
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, password_hash, display_name, created_at FROM users WHERE id = ?
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password_hash, display_name, created_at FROM users WHERE username = ?
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.CreatedAt,
	)
	return i, err
}

const getVocabProgress = `-- name: GetVocabProgress :many
SELECT id, user_id, language, word_id, times_correct, times_incorrect, mastery_level, last_reviewed FROM vocab_progress
WHERE user_id = ? AND language = ?
`

type GetVocabProgressParams struct {
	UserID   int64
	Language string
}

func (q *Queries) GetVocabProgress(ctx context.Context, arg GetVocabProgressParams) ([]VocabProgress, error) {
	rows, err := q.db.QueryContext(ctx, getVocabProgress, arg.UserID, arg.Language)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VocabProgress
	for rows.Next() {
		var i VocabProgress
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Language,
			&i.WordID,
			&i.TimesCorrect,
			&i.TimesIncorrect,
			&i.MasteryLevel,
			&i.LastReviewed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVocabProgressByWord = `-- name: GetVocabProgressByWord :one
SELECT id, user_id, language, word_id, times_correct, times_incorrect, mastery_level, last_reviewed FROM vocab_progress
WHERE user_id = ? AND language = ? AND word_id = ?
`

type GetVocabProgressByWordParams struct {
	UserID   int64
	Language string
	WordID   string
}

func (q *Queries) GetVocabProgressByWord(ctx context.Context, arg GetVocabProgressByWordParams) (VocabProgress, error) {
	row := q.db.QueryRowContext(ctx, getVocabProgressByWord, arg.UserID, arg.Language, arg.WordID)
	var i VocabProgress
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Language,
		&i.WordID,
		&i.TimesCorrect,
		&i.TimesIncorrect,
		&i.MasteryLevel,
		&i.LastReviewed,
	)
	return i, err
}

const listLessonProgress = `-- name: ListLessonProgress :many
SELECT id, user_id, language, lesson_id, status, best_score, attempts, last_accessed, completed_at FROM lesson_progress
WHERE user_id = ? AND language = ?
ORDER BY lesson_id
`

type ListLessonProgressParams struct {
	UserID   int64
	Language string
}

func (q *Queries) ListLessonProgress(ctx context.Context, arg ListLessonProgressParams) ([]LessonProgress, error) {
	rows, err := q.db.QueryContext(ctx, listLessonProgress, arg.UserID, arg.Language)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LessonProgress
	for rows.Next() {
		var i LessonProgress
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Language,
			&i.LessonID,
			&i.Status,
			&i.BestScore,
			&i.Attempts,
			&i.LastAccessed,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuizAttempts = `-- name: ListQuizAttempts :many
SELECT id, user_id, language, lesson_id, score, total_questions, correct_answers, attempted_at FROM quiz_attempts
WHERE user_id = ? AND language = ? AND lesson_id = ?
ORDER BY attempted_at DESC
`

type ListQuizAttemptsParams struct {
	UserID   int64
	Language string
	LessonID string
}

func (q *Queries) ListQuizAttempts(ctx context.Context, arg ListQuizAttemptsParams) ([]QuizAttempt, error) {
	rows, err := q.db.QueryContext(ctx, listQuizAttempts, arg.UserID, arg.Language, arg.LessonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QuizAttempt
	for rows.Next() {
		var i QuizAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Language,
			&i.LessonID,
			&i.Score,
			&i.TotalQuestions,
			&i.CorrectAnswers,
			&i.AttemptedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertLessonProgress = `-- name: UpsertLessonProgress :one
INSERT INTO lesson_progress (user_id, language, lesson_id, status, best_score, attempts, last_accessed, completed_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(user_id, language, lesson_id)
DO UPDATE SET
    status = excluded.status,
    best_score = CASE WHEN excluded.best_score > lesson_progress.best_score THEN excluded.best_score ELSE lesson_progress.best_score END,
    attempts = excluded.attempts,
    last_accessed = excluded.last_accessed,
    completed_at = COALESCE(excluded.completed_at, lesson_progress.completed_at)
RETURNING id, user_id, language, lesson_id, status, best_score, attempts, last_accessed, completed_at
`

type UpsertLessonProgressParams struct {
	UserID       int64
	Language     string
	LessonID     string
	Status       string
	BestScore    sql.NullInt64
	Attempts     sql.NullInt64
	LastAccessed sql.NullTime
	CompletedAt  sql.NullTime
}

func (q *Queries) UpsertLessonProgress(ctx context.Context, arg UpsertLessonProgressParams) (LessonProgress, error) {
	row := q.db.QueryRowContext(ctx, upsertLessonProgress,
		arg.UserID,
		arg.Language,
		arg.LessonID,
		arg.Status,
		arg.BestScore,
		arg.Attempts,
		arg.LastAccessed,
		arg.CompletedAt,
	)
	var i LessonProgress
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Language,
		&i.LessonID,
		&i.Status,
		&i.BestScore,
		&i.Attempts,
		&i.LastAccessed,
		&i.CompletedAt,
	)
	return i, err
}

const upsertVocabProgress = `-- name: UpsertVocabProgress :one
INSERT INTO vocab_progress (user_id, language, word_id, times_correct, times_incorrect, mastery_level, last_reviewed)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(user_id, language, word_id)
DO UPDATE SET
    times_correct = excluded.times_correct,
    times_incorrect = excluded.times_incorrect,
    mastery_level = excluded.mastery_level,
    last_reviewed = excluded.last_reviewed
RETURNING id, user_id, language, word_id, times_correct, times_incorrect, mastery_level, last_reviewed
`

type UpsertVocabProgressParams struct {
	UserID         int64
	Language       string
	WordID         string
	TimesCorrect   sql.NullInt64
	TimesIncorrect sql.NullInt64
	MasteryLevel   sql.NullInt64
	LastReviewed   sql.NullTime
}

func (q *Queries) UpsertVocabProgress(ctx context.Context, arg UpsertVocabProgressParams) (VocabProgress, error) {
	row := q.db.QueryRowContext(ctx, upsertVocabProgress,
		arg.UserID,
		arg.Language,
		arg.WordID,
		arg.TimesCorrect,
		arg.TimesIncorrect,
		arg.MasteryLevel,
		arg.LastReviewed,
	)
	var i VocabProgress
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Language,
		&i.WordID,
		&i.TimesCorrect,
		&i.TimesIncorrect,
		&i.MasteryLevel,
		&i.LastReviewed,
	)
	return i, err
}
